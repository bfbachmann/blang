use {malloc, calloc, realloc, free, memcpy}: "std/libc/mem.bl"

/// Allocates space on the heap for `count` values of type `T` and returns a pointer
/// to the allocated region.
pub fn heap_alloc[T](count: uint) -> *mut T {
    return calloc(sizeof T, count) as *mut T
}

/// Frees the heap space pointed to by `ptr`.
pub fn heap_free[T](ptr: *mut T) {
    free(ptr as *u8)
}

/// Reallocates the heap space referenced by `ptr` so it can store `count` values
/// of type `T`. This will also copy the existing data into the new memory region.
pub fn heap_realloc[T](ptr: *mut T, count: uint) -> *mut T {
    return realloc(ptr as *u8, sizeof T * count) as *mut T
}

/// Copies a `T` from `src` to `dst`. These two pointers must not point to overlapping
/// regions.
pub fn copy[T](dst: *mut T, src: *T) {
    memcpy(dst as *u8, src as *u8, sizeof T)
}

/// Moves `T` onto the heap and returns a pointer to it.
pub fn heap[T](t: T) -> *mut T {
    let ptr = heap_alloc[T](1)
    ptr^ = t
    return ptr
}

/// Replaces the value pointed to by `dst` with `value` and returns the data
/// pointed to by `dst`.
pub fn replace[T](dst: *mut T, mut value: T) -> T {
    swap[T](dst, &mut value)
    return value
}

/// Swaps the data pointed to by `a` and `b`.
pub fn swap[T](a: *mut T, b: *mut T) {
    let a_bytes = a as *mut u8
    let b_bytes = b as *mut u8
    let len = sizeof T as int

    for let mut i = 0, i < len, i += 1 {
        let tmp = a_bytes.(i)^
        a_bytes.(i)^ = b_bytes.(i)^
        b_bytes.(i)^ = tmp
    }
}