use "std/libc/io.bl" @io
use "std/libc/proc.bl" @proc
use "std/backtrace/panic.bl" {assert}

spec Call {
    fn call(*mut self)
}

struct Caller {
    data: *mut Caller
    func: fn (*mut Caller)
}

impl Caller {
    fn new[T: Call](t: *mut T) -> Caller {
        return Caller{
            data: t as *mut Caller
            func: fn (caller: *mut Caller) {
                T.call(caller as *mut T)
            }
        }
    }
}

impl Caller: Call {
    fn call(*mut self) {
        self.func(self.data)
    }
}

struct Inner {
    i: uint
}

impl Inner: Call {
    fn call(*mut self) {
        self.i += 1
    }
}

struct Inner2 {
    s: str
}

impl Inner2: Call {
    fn call(*mut self) {
        self.s = "bla"
    }
}

// This just tests that we can properly call functions that call nested 
// functions that inherit generic parameters from their parents.
fn main() {
    let mut inner2 = Inner2{s: "bing"}
    let mut c2 = Caller.new[Inner2](&mut inner2)
    c2.call()
    assert(inner2.s == "bla", "expected bla")

    let mut inner = Inner{i: 0}
    let mut c = Caller.new[Inner](&mut inner)
    c.call()
    assert(inner.i == 1, "expected 1")

    @proc.exit(0)
}