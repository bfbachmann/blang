use {Program, Instruction, InstKind}: "docs/examples/machine-interpreter/parser.bl"
use {print_str}: "docs/examples/machine-interpreter/utils.bl"

const mem_size: uint = 1024

/// A machine executes a program by manipulating its memory according
/// to program instructions.
pub struct Machine {
    memory: [int; mem_size]
    prog: *Program
    pc: uint
}

/// The result of instruction execution.
pub struct ExecResult {
    pub status: ExecStatus
    pub msg: str
}

/// Indicates whether execution succeeded.
pub enum ExecStatus {
    Ok
    Err
}

impl ExecResult {
    fn new_ok(): ExecResult {
        return ExecResult{
            status: ExecStatus::Ok
            msg: ""
        }
    }

    fn new_err(msg: str): ExecResult {
        return ExecResult{
            status: ExecStatus::Err
            msg: msg
        }
    }
}

impl Machine {
    /// Creates a new machine for executing the given program.
    pub fn new(prog: *Program): Machine {
        return Machine{
            memory: [0; mem_size]
            prog: prog
            pc: 0
        }
    }

    /// Executes the program associated with the machine and returns a result
    /// indicating whether execution succeeded.
    pub fn exec_prog(*mut self): ExecResult {
        for self^.pc = 0,
            self^.pc < self^.prog.len(),
            self^.pc += 1
        {
            let inst_ptr = self^.prog.inst_at(self^.pc)
            let result = self.exec_inst(inst_ptr)
            if result.status ~~ ExecStatus::Err {
                return result
            }
        }

        return ExecResult.new_ok()
    }


    /// Executes an instruction.
    fn exec_inst(*mut self, inst: *Instruction): ExecResult {
        if inst^.kind ~~ InstKind::Store {
            print_str("store\n")
            return self.store(inst^.operands.(0), inst^.operands.(1) as uint)
        }

        if inst^.kind ~~ InstKind::Copy {
            print_str("copy\n")
            return self.copy(inst^.operands.(0) as uint, inst^.operands.(1) as uint)
        }

        if inst^.kind ~~ InstKind::Add {
            print_str("add\n")
            return self.add(inst^.operands.(0) as uint, inst^.operands.(1) as uint)
        }

        if inst^.kind ~~ InstKind::JumpIf0 {
            print_str("jumpif0\n")
            return self.jumpif0(inst^.operands.(0) as uint, inst^.operands.(1) as uint)
        }

        return ExecResult.new_err("unimplemented instruction")
    }

    /// Executes a store instruction.
    fn store(*mut self, value: int, addr: uint): ExecResult {
        if addr >= mem_size {
            return ExecResult.new_err("store address out of bounds")
        }

        self^.memory.(addr) = value
        return ExecResult.new_ok()
    }

    /// Executes a copy instruction.
    fn copy(*mut self, src_addr: uint, dst_addr: uint): ExecResult {
        if src_addr >= mem_size {
            return ExecResult.new_err("copy source address out of bounds")
        }

        if dst_addr >= mem_size {
            return ExecResult.new_err("copy destination address out of bounds")
        }

        self^.memory.(dst_addr) = self^.memory.(src_addr)
        return ExecResult.new_ok()
    }

    /// Executes an add instruction.
    fn add(*mut self, src_addr: uint, dst_addr: uint): ExecResult {
        if src_addr >= mem_size {
            return ExecResult.new_err("add source address out of bounds")
        }

        if dst_addr >= mem_size {
            return ExecResult.new_err("add destination address out of bounds")
        }

        self^.memory.(dst_addr) += self^.memory.(src_addr)
        return ExecResult.new_ok()
    }

    /// Executes a jumpif0 instruction.
    fn jumpif0(*mut self, src_addr: uint, dst_inst: uint): ExecResult {
        if src_addr >= mem_size {
            return ExecResult.new_err("jumpif0 source address out of bounds")
        }

        if dst_inst >= self^.prog.len() {
            return ExecResult.new_err("jumpif0 destination address out of bounds")
        }

        if self^.memory.(src_addr) == 0 {
            self^.pc = dst_inst - 1
        }

        return ExecResult.new_ok()
    }

    /// Returns the int in memory at the given index.
    pub fn memory_at(*self, index: uint): int {
        return self^.memory.(index)
    }
}
